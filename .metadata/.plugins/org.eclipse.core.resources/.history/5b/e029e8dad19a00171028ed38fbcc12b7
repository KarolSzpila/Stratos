/*
 * fm_radio.c
 *
 *  Created on: 01.09.2017
 *      Author: Karol
 */

#include "fm_radio.h"
#include "stm32f4xx_hal.h"
#include "string.h"
#include <stdint.h>

#define SIZE 1024
static struct FMRadio self;

unsigned char usbbuf[SIZE];
uint16_t magnitude[SIZE];
uint16_t maglut[129*129*2];

static int r = -1;

#define MODES_PREAMBLE_US 8       /* microseconds */
#define MODES_LONG_MSG_BITS 112
#define MODES_SHORT_MSG_BITS 56
#define MODES_FULL_LEN (MODES_PREAMBLE_US+MODES_LONG_MSG_BITS)
#define MODES_LONG_MSG_BYTES (112/8)
#define MODES_SHORT_MSG_BYTES (56/8)


void computeMagnitudeVector(void) {
    uint32_t j;

    /* Compute the magnitudo vector. It's just SQRT(I^2 + Q^2), but
     * we rescale to the 0-255 range to exploit the full resolution. */
    for (j = 0; j < SIZE; j += 2) {
        int i = usbbuf[j]-127;
        int q = usbbuf[j+1]-127;

        if (i < 0) i = -i;
        if (q < 0) q = -q;
        magnitude[j/2] = maglut[i*129+q];
    }

}

void detectModeS(uint16_t *m, uint32_t mlen) {
    unsigned char bits[MODES_LONG_MSG_BITS];
    unsigned char msg[MODES_LONG_MSG_BITS/2];
    uint16_t aux[MODES_LONG_MSG_BITS*2];
    uint32_t j;
    int use_correction = 0;

    for (j = 0; j < mlen - MODES_FULL_LEN*2; j++) {
        int low, high, delta, i, errors;
        int good_message = 0;

        //if (use_correction) goto good_preamble; /* We already checked it. */

        /* First check of relations between the first 10 samples
         * representing a valid preamble. We don't even investigate further
         * if this simple test is not passed. */
        if (!(magnitude[j] > magnitude[j+1] &&
            magnitude[j+1] < magnitude[j+2] &&
            magnitude[j+2] > magnitude[j+3] &&
            magnitude[j+3] < magnitude[j] &&
            magnitude[j+4] < magnitude[j] &&
            magnitude[j+5] < magnitude[j] &&
            magnitude[j+6] < magnitude[j] &&
            magnitude[j+7] > magnitude[j+8] &&
            magnitude[j+8] < magnitude[j+9] &&
            magnitude[j+9] > magnitude[j+6]))
        {
        	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_13,GPIO_PIN_SET);
            break;
        }
        HAL_GPIO_WritePin(GPIOG,GPIO_PIN_14,GPIO_PIN_SET);
    }
}

int fmradio_init() {

    dev = &static_dev;

    self.tuner_ppm_error = 0;
    self.tuner_frequency = 1090000000;
    self.adc_samp_rate = 2000000;
    self.is_raw_buf_complete = 0;

    memset(usbbuf,0,SIZE);
    memset(magnitude,0,SIZE);


       for (uint8_t i = 0; i <= 128; i++) {
           for (uint8_t q = 0; q <= 128; q++) {
               maglut[i*129+q] = round(sqrt(i*i+q*q)*360);
           }
       }


    int8_t dongle_open = rtlsdr_open(&dev, 0);

    if (dongle_open < 0) {
        //DEBUG_PRINT("Failed to open rtlsdr device (%i).\n", dongle_open);
        return dongle_open;
    } else {
        //DEBUG_PRINT("Opened rtlsdr\n");
    }

    // Set the sample rate
    r = verbose_set_sample_rate(dev, self.adc_samp_rate);

    // Set the frequency
    r = verbose_set_frequency(dev, self.tuner_frequency);

    // set auto gain
    r = verbose_auto_gain(dev);

    // set ppm error
    r = verbose_ppm_set(dev, self.tuner_ppm_error);

    // Reset endpoint before we start reading from it (mandatory)
    r = verbose_reset_buffer(dev);

    //DEBUG_PRINT("Starting user app\n");
    usbbuf[512] = 'a';
    // begin capture radio data
    self.is_usb_app_started = 1;
    rtlsdr_read_sync(dev, usbbuf, 8, 0);
    return 0;

}

void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
{
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif

  UNUSED(hhcd);
  UNUSED(chnum);

  if (!self.is_usb_app_started) { return; }

  if (urb_state == URB_DONE)
  {

	  computeMagnitudeVector();
	  detectModeS(magnitude,512);
	  rtlsdr_read_sync(dev, usbbuf, 8, 0);
  }
  else if(urb_state == URB_ERROR)
  {
	  //HAL_GPIO_TogglePin(GPIOG,GPIO_PIN_13);
  }
}
/*
void fmradio_process() {

    // run init
    if (!self.is_usb_app_started) fmradio_init();

    // wait for raw buffer to fill completely
    if (!self.is_raw_buf_complete) return;

    // reset buffer completion flag
    self.is_raw_buf_complete = 0;

    // trace event
    trace_itm_print(3,0);

    // demodulate and downsample the completed raw buffer
    uint32_t demod_index = 0;
    volatile uint8_t* raw_buf_complete = (raw_buf_filling == raw_bufA) ? raw_bufB : raw_bufA;

    for (uint32_t sample_index = 0;
            (sample_index + (2 * DOWNSAMPLE) + 3) < RAW_BUFFER_BYTES;
            sample_index += 2 * DOWNSAMPLE) {

        // todo reconsider -127 offset as samples are actually only 7-bit reso
        int16_t s1[2], s2[2];
        s1[0] = (int16_t)raw_buf_complete[sample_index + 0] - 127; // I
        s1[1] = (int16_t)raw_buf_complete[sample_index + 1] - 127; // Q
        s2[0] = (int16_t)raw_buf_complete[sample_index + 2] - 127; // I
        s2[1] = (int16_t)raw_buf_complete[sample_index + 3] - 127; // Q

        // find the phase shift in these two samples (this is the essence of the FM demod)
        int16_t pcm = fmradio_polar_disc(s2[0], s2[1], s1[0], s1[1]);

        pcm = pcm * 8.0f / PI; // scale from radians

        // TODO: dc block filter and low pass filter

        // note: audio codec currently expects stereo sample buffer
        curr_demod_buff[demod_index++] = pcm; // right channel
        curr_demod_buff[demod_index++] = pcm; // left channel

    }

    // play demodulated buffer
    audio_set_next_segment((int16_t*)curr_demod_buff, 2*demod_index);

    // swap demod buffers
    curr_demod_buff = (curr_demod_buff == demod_bufferA) ? demod_bufferB : demod_bufferA;

}*/
