/**
  ******************************************************************************
  * @file    usbh_rtlsdr.c
  * @author  Victor Pecanins <vpecanins@gmail.com>
  * @version V0.1
  * @date    25/09/2016
  * @brief   RTLSDR Driver for STM32F7 using ST's USBHost
  *
  *
  ******************************************************************************
  * @attention
  *
  * This file can be considered a derived work from librtlsdr.c, a part from
  * the original rtl-sdr package. The routines have been adapted to work in
  * the STM32 USB Host environment, by incorporating them in a hierarchical
  * finite state machine.
  *
  *
  * It follows the original copyright notice from librtlsdr:
  *
  * rtl-sdr, turns your Realtek RTL2832 based DVB dongle into a SDR receiver
  * Copyright (C) 2012-2014 by Steve Markgraf <steve@steve-m.de>
  * Copyright (C) 2012 by Dimitri Stolnikov <horiz0n@gmx.net>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  *
  * In order to write the code for a specific Class for USBH, the code
  * of CDC Class (found in Middlewares on the ST Cube F7 package) has been
  * modified. It follows the original notice from the ST Middleware code:
  *
  *   * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "usbh_rtlsdr.h"

#include "tuner_e4k.h"
#include "tuner_fc0012.h"
#include "tuner_fc0013.h"
#include "tuner_fc2580.h"
#include "tuner_r82xx.h"

uint8_t buff[512];
/** @addtogroup USBH_LIB
* @{
*/

/** @addtogroup USBH_CLASS
* @{
*/

/** @addtogroup USBH_RTLSDR_CLASS
* @{
*/

/** @defgroup USBH_RTLSDR_CORE
* @brief    This file includes RTLSDR Layer Handlers for USB Host RTLSDR class.
* @{
*/

/** @defgroup USBH_RTLSDR_CORE_Private_TypesDefinitions
* @{
*/
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Defines
* @{
*/
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Macros
* @{
*/

/* two raised to the power of n */
#define TWO_POW(n)		((double)(1ULL<<(n)))

/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Variables
* @{
*/
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_FunctionPrototypes
* @{
*/

static USBH_StatusTypeDef USBH_RTLSDR_InterfaceInit  (USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_InterfaceDeInit  (USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_Process(USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_SOFProcess(USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_ClassRequest (USBH_HandleTypeDef *phost);


USBH_ClassTypeDef  RTLSDR_Class =
{
  "RTLSDR",
  USB_RTLSDR_CLASS,
  USBH_RTLSDR_InterfaceInit,
  USBH_RTLSDR_InterfaceDeInit,
  USBH_RTLSDR_ClassRequest,
  USBH_RTLSDR_Process,
  USBH_RTLSDR_SOFProcess,
  NULL,
};
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Functions
* @{
*/

/**
  * @brief  USBH_RTLSDR_InterfaceInit
  *         The function init the RTLSDR class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_RTLSDR_InterfaceInit (USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef status = USBH_OK ;
  uint8_t interface;
  RTLSDR_HandleTypeDef *RTLSDR_Handle;

  interface = USBH_FindInterface(phost,
                                 USB_RTLSDR_CLASS,
                                 USB_RTLSDR_SUBCLASS,
                                 VENDOR_SPECIFIC);

	if(interface == 0xFF) {
		/* No Valid Interface */
		USBH_DbgLog ("Cannot Find the interface for class: %s", phost->pActiveClass->Name);
	} else {
		/* Found valid interface */
		USBH_DbgLog ("Found interface for class: %s", phost->pActiveClass->Name);
		USBH_SelectInterface (phost, interface);

		phost->pActiveClass->pData =
		  (RTLSDR_HandleTypeDef *)USBH_malloc (sizeof(RTLSDR_HandleTypeDef));

		RTLSDR_Handle =  (RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

		/* Initialize the FSM for writing the initialization registers */
		RTLSDR_Handle->demodState = RTLSDR_DEM_WRITE_WAIT;
		RTLSDR_Handle->reqState  = RTLSDR_REQ_STARTWAIT;
		RTLSDR_Handle->reqNumber = 0;
		RTLSDR_Handle->firState = RTLSDR_FIR_CALC;
		RTLSDR_Handle->firNumber = 0;
		RTLSDR_Handle->probeState = RTLSDR_PROBE_R820T;
		RTLSDR_Handle->i2cState = RTLSDR_I2C_WRITE_WAIT;
		RTLSDR_Handle->tuner = 0;
		RTLSDR_Handle->xferState = RTLSDR_XFER_START;
		RTLSDR_Handle->setSampleRateState=0;

		/*Collect the SDR sample stream endpoint address and length*/
		if(phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress &
		   0x80)
		{
			RTLSDR_Handle->CommItf.SdrEp =
			phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress;

			RTLSDR_Handle->CommItf.SdrEpSize  =
			phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
		}

		USBH_DbgLog ("Sdr EP: 0x%02X, Size: %d",
					 RTLSDR_Handle->CommItf.SdrEp,
					 RTLSDR_Handle->CommItf.SdrEpSize);

		/*Allocate the length for host channel number in*/
		RTLSDR_Handle->CommItf.SdrPipe =
		  USBH_AllocPipe(phost, RTLSDR_Handle->CommItf.SdrEp);

		/* Open pipe for SDR sample stream endpoint */
		USBH_OpenPipe  (phost,
						RTLSDR_Handle->CommItf.SdrPipe,
						RTLSDR_Handle->CommItf.SdrEp,
						phost->device.address,
						phost->device.speed,
						USB_EP_TYPE_BULK,
						RTLSDR_Handle->CommItf.SdrEpSize);

		RTLSDR_Handle->CommItf.buff = buff;

    /* This should be user configurable. It gives expected throughput values from 32..127 *512 */
    RTLSDR_Handle->CommItf.buffSize = 1*512;

		USBH_LL_SetToggle (phost, RTLSDR_Handle->CommItf.SdrPipe, 0);

	return status;
}
/*
uint16_t RTLSDR_read_reg (USBH_HandleTypeDef *phost,
                          uint8_t block,
                          uint16_t addr,
                          uint8_t len)
{

}*/

USBH_StatusTypeDef RTLSDR_write_reg(USBH_HandleTypeDef *phost,
                     uint8_t block,
                     uint16_t addr,
                     uint16_t val,
                     uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
		(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	if(phost->RequestState == CMD_SEND) {

		// "index"
		RTLSDR_Handle->regWriteIndex = (block << 8) | 0x10;

		// "data"
		if (len == 1)
		  RTLSDR_Handle->regWriteData[0] = val & 0xff;
		else
		  RTLSDR_Handle->regWriteData[0] = val >> 8;

		RTLSDR_Handle->regWriteData[1] = val & 0xff;

		// Setup packet parameters
		phost->Control.setup.b.bmRequestType = CTRL_OUT;
		phost->Control.setup.b.bRequest = 0;
		phost->Control.setup.b.wValue.w = addr;
		phost->Control.setup.b.wIndex.w = RTLSDR_Handle->regWriteIndex;
		phost->Control.setup.b.wLength.w = len;
    }

	return USBH_CtlReq(phost, &(RTLSDR_Handle->regWriteData[0]), len);
}


USBH_StatusTypeDef RTLSDR_read_array(USBH_HandleTypeDef *phost,
                      uint8_t block,
                      uint16_t addr,
                      uint8_t *array,
                      uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
		(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	if(phost->RequestState == CMD_SEND) {
		// "index"
		RTLSDR_Handle->arrReadIndex = (block << 8);

		// Setup packet parameters
		phost->Control.setup.b.bmRequestType = CTRL_IN;
		phost->Control.setup.b.bRequest = 0;
		phost->Control.setup.b.wValue.w = addr;
		phost->Control.setup.b.wIndex.w = RTLSDR_Handle->arrReadIndex;
		phost->Control.setup.b.wLength.w = len;
	}

	return USBH_CtlReq(phost, array, len);
}

USBH_StatusTypeDef RTLSDR_write_array(USBH_HandleTypeDef *phost,
                       uint8_t block,
                       uint16_t addr,
                       uint8_t *array,
                       uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
		(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	if(phost->RequestState == CMD_SEND) {

		// "index"
		RTLSDR_Handle->arrWriteIndex = (block << 8) | 0x10;

		// Setup packet parameters
		phost->Control.setup.b.bmRequestType = CTRL_OUT;
		phost->Control.setup.b.bRequest = 0;
		phost->Control.setup.b.wValue.w = addr;
		phost->Control.setup.b.wIndex.w = RTLSDR_Handle->arrWriteIndex;
		phost->Control.setup.b.wLength.w = len;

	}

	return USBH_CtlReq(phost, array, len);
}

uint8_t RTLSDR_i2c_read_reg(USBH_HandleTypeDef *phost,
                            uint8_t i2c_addr,
                            uint8_t reg)
{
  RTLSDR_HandleTypeDef *RTLSDR_Handle =
    (RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	USBH_StatusTypeDef uStatus = USBH_FAIL;
	USBH_StatusTypeDef rStatus = USBH_BUSY;

	RTLSDR_Handle->i2cReadAddress = i2c_addr;
	RTLSDR_Handle->i2cReadReg = reg;
	RTLSDR_Handle->i2cReadVal = 0x00;

	switch (RTLSDR_Handle->i2cState) {
	case RTLSDR_I2C_WRITE_WAIT:

	  uStatus = RTLSDR_write_array(phost,
									IICB,
									RTLSDR_Handle->i2cReadAddress,
									&(RTLSDR_Handle->i2cReadReg),
									1);

	  if (uStatus == USBH_OK) {
		rStatus = USBH_BUSY;
		RTLSDR_Handle->i2cState = RTLSDR_I2C_READ_WAIT;
	  } else if (uStatus == USBH_NOT_SUPPORTED) {
		rStatus = USBH_BUSY;
	  } else {
		rStatus = uStatus;
	  }
	break;

	case RTLSDR_I2C_READ_WAIT:

	  uStatus = RTLSDR_read_array(phost,
								   IICB,
								   RTLSDR_Handle->i2cReadAddress,
								   &(RTLSDR_Handle->i2cReadData[0]),
								   1);

	  if (uStatus == USBH_OK) {
		RTLSDR_Handle->i2cReadVal = RTLSDR_Handle->i2cReadData[0];
		RTLSDR_Handle->i2cState = RTLSDR_I2C_WRITE_WAIT;
		rStatus = uStatus;
	  } else if (uStatus == USBH_NOT_SUPPORTED) {
		rStatus = USBH_BUSY;
	  } else {
		rStatus = uStatus;

	  }
	break;
	}

	return rStatus;
}

/* I2C routines */
USBH_StatusTypeDef RTLSDR_i2c_write_reg(USBH_HandleTypeDef *phost, uint8_t i2c_addr, uint8_t reg, uint8_t val)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
    (RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	RTLSDR_Handle->i2cWriteAddress = i2c_addr;

	RTLSDR_Handle->i2cWriteData[0] = reg;
	RTLSDR_Handle->i2cWriteData[1] = val;

	return RTLSDR_write_array(phost, IICB, RTLSDR_Handle->i2cWriteAddress, &(RTLSDR_Handle->i2cWriteData[0]), 2);
}

USBH_StatusTypeDef RTLSDR_i2c_write(USBH_HandleTypeDef *phost, uint8_t i2c_addr, uint8_t *buffer, uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
    (RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	RTLSDR_Handle->i2cWriteAddress = i2c_addr;

	return RTLSDR_write_array(phost, IICB, RTLSDR_Handle->i2cWriteAddress, buffer, len);
}

USBH_StatusTypeDef RTLSDR_i2c_read(USBH_HandleTypeDef *phost, uint8_t i2c_addr, uint8_t *buffer, uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
    (RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	RTLSDR_Handle->i2cReadAddress = i2c_addr;

	return RTLSDR_read_array(phost, IICB, RTLSDR_Handle->i2cReadAddress, buffer, len);
}

/* Demod routines */
USBH_StatusTypeDef RTLSDR_demod_read_reg(USBH_HandleTypeDef *phost, uint8_t page, uint16_t addr, uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
	(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	if ( phost->RequestState == CMD_SEND ) {

		RTLSDR_Handle->demodReadIndex = page;
		RTLSDR_Handle->demodReadAddr = (addr << 8) | 0x20;

		phost->Control.setup.b.bmRequestType = CTRL_IN;
		phost->Control.setup.b.bRequest = 0;
		phost->Control.setup.b.wValue.w = RTLSDR_Handle->demodReadAddr;
		phost->Control.setup.b.wIndex.w = RTLSDR_Handle->demodReadIndex;
		phost->Control.setup.b.wLength.w = len;
	}

	USBH_StatusTypeDef uStatus = USBH_CtlReq(phost, &(RTLSDR_Handle->demodReadData[0]), len);

	RTLSDR_Handle->demodRead = (RTLSDR_Handle->demodWriteData[1] << 8) | RTLSDR_Handle->demodWriteData[0];

	return uStatus;
}

USBH_StatusTypeDef RTLSDR_demod_write_reg(USBH_HandleTypeDef *phost, uint8_t page, uint16_t addr, uint16_t val, uint8_t len)
{
  RTLSDR_HandleTypeDef *RTLSDR_Handle =
    (RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

  USBH_StatusTypeDef uStatus = USBH_FAIL;
  USBH_StatusTypeDef rStatus = USBH_BUSY;

  switch (RTLSDR_Handle->demodState) {
    case RTLSDR_DEM_WRITE_WAIT:

		if ( phost->RequestState == CMD_SEND ) {
			RTLSDR_Handle->demodWriteIndex = 0x10 | page;
			RTLSDR_Handle->demodWriteAddr = (addr << 8) | 0x20;

			if (len == 1)
				RTLSDR_Handle->demodWriteData[0] = val & 0xff;
			else
				RTLSDR_Handle->demodWriteData[0] = val >> 8;

			RTLSDR_Handle->demodWriteData[1] = val & 0xff;

			phost->Control.setup.b.bmRequestType = CTRL_OUT;
			phost->Control.setup.b.bRequest = 0;
			phost->Control.setup.b.wValue.w = RTLSDR_Handle->demodWriteAddr;
			phost->Control.setup.b.wIndex.w = RTLSDR_Handle->demodWriteIndex;
			phost->Control.setup.b.wLength.w = len;
		}

		uStatus = USBH_CtlReq(phost, &(RTLSDR_Handle->demodWriteData[0]), len);

		if (uStatus == USBH_OK) {
			RTLSDR_Handle->demodState = RTLSDR_DEM_READ_WAIT;
			rStatus = USBH_BUSY;
		} else {
			rStatus = uStatus;
		}

    break;

    case RTLSDR_DEM_READ_WAIT:
      // You really need to do this read after writing? (Why?)
		uStatus = RTLSDR_demod_read_reg(phost, 0x0a, 0x01, 1);

		if (uStatus == USBH_OK) {
			RTLSDR_Handle->demodState = RTLSDR_DEM_WRITE_WAIT;
			rStatus = USBH_OK;
		} else {
			rStatus = uStatus;
		}

    break;
  }

	return rStatus;
}

/* I2C Repeater control */
USBH_StatusTypeDef RTLSDR_set_i2c_repeater(USBH_HandleTypeDef *phost, int on)
{
	return RTLSDR_demod_write_reg(phost, 1, 0x01, on ? 0x18 : 0x10, 1);
}

/* FIR routine */
USBH_StatusTypeDef RTLSDR_set_fir(USBH_HandleTypeDef *phost)
{

	RTLSDR_HandleTypeDef *RTLSDR_Handle =
	(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	USBH_StatusTypeDef uStatus = USBH_FAIL;
	USBH_StatusTypeDef rStatus = USBH_BUSY;


	int i;
	int val;
	int val0;
	int val1;

	//USBH_DbgLog("firState=%d, firNumber=%d", RTLSDR_Handle->firState, RTLSDR_Handle->firNumber);
	//USBH_DbgLog("firState=%d, firNumber=%d", RTLSDR_Handle->firState, 0);
	switch (RTLSDR_Handle->firState) {
	  case RTLSDR_FIR_CALC:
	    /* format: int8_t[8] */
	    for (i = 0; i < 8; ++i) {
		    val = RTLSDR_FIR[i];
		    if (val < -128 || val > 127) {
			    USBH_DbgLog("Invalid FIR coefficient!");
		    }
		    RTLSDR_Handle->fir[i] = val;
	    }

	    /* format: int12_t[8] */
	    for (i = 0; i < 8; i += 2) {
		    val0 = RTLSDR_FIR[8+i];
		    val1 = RTLSDR_FIR[8+i+1];
		    if (val0 < -2048 || val0 > 2047 || val1 < -2048 || val1 > 2047) {
			    USBH_DbgLog("Invalid FIR coefficient!");
		    }
		    RTLSDR_Handle->fir[8+i*3/2] = val0 >> 4;
		    RTLSDR_Handle->fir[8+i*3/2+1] = (val0 << 4) | ((val1 >> 8) & 0x0f);
		    RTLSDR_Handle->fir[8+i*3/2+2] = val1;
	    }
	    RTLSDR_Handle->firState = RTLSDR_FIR_WRITE_WAIT;
	    RTLSDR_Handle->firNumber = 0;
	  break;

    case RTLSDR_FIR_WRITE_WAIT:
      uStatus = RTLSDR_demod_write_reg(phost,
										1,
                                        0x1c + RTLSDR_Handle->firNumber,
                                        RTLSDR_Handle->fir[RTLSDR_Handle->firNumber],
                                        1);

      if (uStatus == USBH_OK) RTLSDR_Handle->firState = RTLSDR_FIR_INC;

      rStatus = USBH_BUSY;
    break;

	  /* Increment the reqNumber pointing to the next FIR reg */
    case RTLSDR_FIR_INC:
      if (RTLSDR_Handle->firNumber == 19) {
        RTLSDR_Handle->firState = RTLSDR_FIR_COMPLETE;
        RTLSDR_Handle->firNumber = 0;
      } else {
        RTLSDR_Handle->firNumber++;
        RTLSDR_Handle->firState = RTLSDR_FIR_WRITE_WAIT;
      }
      rStatus = USBH_BUSY;
    break;

    /* FIR writing complete, exit sub FSM */
    case RTLSDR_FIR_COMPLETE:
      RTLSDR_Handle->firState = RTLSDR_FIR_CALC;
      rStatus = USBH_OK;
    break;

    default:

    break;
  }

	return rStatus;
}

/**
  * @brief  USBH_RTLSDR_InterfaceDeInit
  *         The function DeInit the Pipes used for the RTLSDR class.
  * @param  phost: Host handle
  * @retval USBH Status
  */








/**
  * @brief  USBH_RTLSDR_ClassRequest
  *         The function is responsible for handling Standard requests
  *         for RTLSDR class.
  * @param  phost: Host handle
  * @retval USBH Status
  */


/**
  * @brief  RTLSDR_probe_tuners
  *         This is a sub-FSM to check what tuner we have.
  * @param  phost: Host handle
  * @retval USBH Status
  */




/**
  * @brief  USBH_RTLSDR_Process
  *         The function is for managing state machine for RTLSDR data transfers
  * @param  phost: Host handle
  * @retval USBH Status
  */
