/**
  ******************************************************************************
  * @file    usbh_rtlsdr.c
  * @author  Victor Pecanins <vpecanins@gmail.com>
  * @version V0.1
  * @date    25/09/2016
  * @brief   RTLSDR Driver for STM32F7 using ST's USBHost
  *
  *
  ******************************************************************************
  * @attention
  *
  * This file can be considered a derived work from librtlsdr.c, a part from
  * the original rtl-sdr package. The routines have been adapted to work in
  * the STM32 USB Host environment, by incorporating them in a hierarchical
  * finite state machine.
  *
  *
  * It follows the original copyright notice from librtlsdr:
  *
  * rtl-sdr, turns your Realtek RTL2832 based DVB dongle into a SDR receiver
  * Copyright (C) 2012-2014 by Steve Markgraf <steve@steve-m.de>
  * Copyright (C) 2012 by Dimitri Stolnikov <horiz0n@gmx.net>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  *
  * In order to write the code for a specific Class for USBH, the code
  * of CDC Class (found in Middlewares on the ST Cube F7 package) has been
  * modified. It follows the original notice from the ST Middleware code:
  *
  *   * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "usbh_rtlsdr.h"

#include "tuner_e4k.h"
#include "tuner_fc0012.h"
#include "tuner_fc0013.h"
#include "tuner_fc2580.h"
#include "tuner_r82xx.h"

uint8_t buff[512];
/** @addtogroup USBH_LIB
* @{
*/

/** @addtogroup USBH_CLASS
* @{
*/

/** @addtogroup USBH_RTLSDR_CLASS
* @{
*/

/** @defgroup USBH_RTLSDR_CORE
* @brief    This file includes RTLSDR Layer Handlers for USB Host RTLSDR class.
* @{
*/

/** @defgroup USBH_RTLSDR_CORE_Private_TypesDefinitions
* @{
*/
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Defines
* @{
*/
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Macros
* @{
*/

/* two raised to the power of n */
#define TWO_POW(n)		((double)(1ULL<<(n)))

/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Variables
* @{
*/
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_FunctionPrototypes
* @{
*/

static USBH_StatusTypeDef USBH_RTLSDR_InterfaceInit  (USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_InterfaceDeInit  (USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_Process(USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_SOFProcess(USBH_HandleTypeDef *phost);

static USBH_StatusTypeDef USBH_RTLSDR_ClassRequest (USBH_HandleTypeDef *phost);


USBH_ClassTypeDef  RTLSDR_Class =
{
  "RTLSDR",
  USB_RTLSDR_CLASS,
  USBH_RTLSDR_InterfaceInit,
  USBH_RTLSDR_InterfaceDeInit,
  USBH_RTLSDR_ClassRequest,
  USBH_RTLSDR_Process,
  USBH_RTLSDR_SOFProcess,
  NULL,
};
/**
* @}
*/


/** @defgroup USBH_RTLSDR_CORE_Private_Functions
* @{
*/

/**
  * @brief  USBH_RTLSDR_InterfaceInit
  *         The function init the RTLSDR class.
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_RTLSDR_InterfaceInit (USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef status = USBH_OK ;
  uint8_t interface;
  RTLSDR_HandleTypeDef *RTLSDR_Handle;

  interface = USBH_FindInterface(phost,
                                 USB_RTLSDR_CLASS,
                                 USB_RTLSDR_SUBCLASS,
                                 VENDOR_SPECIFIC);

	if(interface == 0xFF) {
		/* No Valid Interface */
		USBH_DbgLog ("Cannot Find the interface for class: %s", phost->pActiveClass->Name);
	} else {
		/* Found valid interface */
		USBH_DbgLog ("Found interface for class: %s", phost->pActiveClass->Name);
		USBH_SelectInterface (phost, interface);

		phost->pActiveClass->pData =
		  (RTLSDR_HandleTypeDef *)USBH_malloc (sizeof(RTLSDR_HandleTypeDef));

		RTLSDR_Handle =  (RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

		/* Initialize the FSM for writing the initialization registers */
		RTLSDR_Handle->demodState = RTLSDR_DEM_WRITE_WAIT;
		RTLSDR_Handle->reqState  = RTLSDR_REQ_STARTWAIT;
		RTLSDR_Handle->reqNumber = 0;
		RTLSDR_Handle->firState = RTLSDR_FIR_CALC;
		RTLSDR_Handle->firNumber = 0;
		RTLSDR_Handle->probeState = RTLSDR_PROBE_R820T;
		RTLSDR_Handle->i2cState = RTLSDR_I2C_WRITE_WAIT;
		RTLSDR_Handle->tuner = 0;
		RTLSDR_Handle->xferState = RTLSDR_XFER_START;
		RTLSDR_Handle->setSampleRateState=0;

		/*Collect the SDR sample stream endpoint address and length*/
		if(phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress &
		   0x80)
		{
			RTLSDR_Handle->CommItf.SdrEp =
			phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].bEndpointAddress;

			RTLSDR_Handle->CommItf.SdrEpSize  =
			phost->device.CfgDesc.Itf_Desc[interface].Ep_Desc[0].wMaxPacketSize;
		}

		USBH_DbgLog ("Sdr EP: 0x%02X, Size: %d",
					 RTLSDR_Handle->CommItf.SdrEp,
					 RTLSDR_Handle->CommItf.SdrEpSize);

		/*Allocate the length for host channel number in*/
		RTLSDR_Handle->CommItf.SdrPipe =
		  USBH_AllocPipe(phost, RTLSDR_Handle->CommItf.SdrEp);

		/* Open pipe for SDR sample stream endpoint */
		USBH_OpenPipe  (phost,
						RTLSDR_Handle->CommItf.SdrPipe,
						RTLSDR_Handle->CommItf.SdrEp,
						phost->device.address,
						phost->device.speed,
						USB_EP_TYPE_BULK,
						RTLSDR_Handle->CommItf.SdrEpSize);

		RTLSDR_Handle->CommItf.buff = buff;

    /* This should be user configurable. It gives expected throughput values from 32..127 *512 */
    RTLSDR_Handle->CommItf.buffSize = 1*512;

		USBH_LL_SetToggle (phost, RTLSDR_Handle->CommItf.SdrPipe, 0);

	return status;
}
/*
uint16_t RTLSDR_read_reg (USBH_HandleTypeDef *phost,
                          uint8_t block,
                          uint16_t addr,
                          uint8_t len)
{

}*/

USBH_StatusTypeDef RTLSDR_write_reg(USBH_HandleTypeDef *phost,
                     uint8_t block,
                     uint16_t addr,
                     uint16_t val,
                     uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
		(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	if(phost->RequestState == CMD_SEND) {

		// "index"
		RTLSDR_Handle->regWriteIndex = (block << 8) | 0x10;

		// "data"
		if (len == 1)
		  RTLSDR_Handle->regWriteData[0] = val & 0xff;
		else
		  RTLSDR_Handle->regWriteData[0] = val >> 8;

		RTLSDR_Handle->regWriteData[1] = val & 0xff;

		// Setup packet parameters
		phost->Control.setup.b.bmRequestType = CTRL_OUT;
		phost->Control.setup.b.bRequest = 0;
		phost->Control.setup.b.wValue.w = addr;
		phost->Control.setup.b.wIndex.w = RTLSDR_Handle->regWriteIndex;
		phost->Control.setup.b.wLength.w = len;
    }

	return USBH_CtlReq(phost, &(RTLSDR_Handle->regWriteData[0]), len);
}


USBH_StatusTypeDef RTLSDR_read_array(USBH_HandleTypeDef *phost,
                      uint8_t block,
                      uint16_t addr,
                      uint8_t *array,
                      uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
		(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	if(phost->RequestState == CMD_SEND) {
		// "index"
		RTLSDR_Handle->arrReadIndex = (block << 8);

		// Setup packet parameters
		phost->Control.setup.b.bmRequestType = CTRL_IN;
		phost->Control.setup.b.bRequest = 0;
		phost->Control.setup.b.wValue.w = addr;
		phost->Control.setup.b.wIndex.w = RTLSDR_Handle->arrReadIndex;
		phost->Control.setup.b.wLength.w = len;
	}

	return USBH_CtlReq(phost, array, len);
}

USBH_StatusTypeDef RTLSDR_write_array(USBH_HandleTypeDef *phost,
                       uint8_t block,
                       uint16_t addr,
                       uint8_t *array,
                       uint8_t len)
{
	RTLSDR_HandleTypeDef *RTLSDR_Handle =
		(RTLSDR_HandleTypeDef*) phost->pActiveClass->pData;

	if(phost->RequestState == CMD_SEND) {

		// "index"
		RTLSDR_Handle->arrWriteIndex = (block << 8) | 0x10;

		// Setup packet parameters
		phost->Control.setup.b.bmRequestType = CTRL_OUT;
		phost->Control.setup.b.bRequest = 0;
		phost->Control.setup.b.wValue.w = addr;
		phost->Control.setup.b.wIndex.w = RTLSDR_Handle->arrWriteIndex;
		phost->Control.setup.b.wLength.w = len;

	}

	return USBH_CtlReq(phost, array, len);
}



/* I2C routines */


/* Demod routines */






/* FIR routine */

/**
  * @brief  USBH_RTLSDR_InterfaceDeInit
  *         The function DeInit the Pipes used for the RTLSDR class.
  * @param  phost: Host handle
  * @retval USBH Status
  */








/**
  * @brief  USBH_RTLSDR_ClassRequest
  *         The function is responsible for handling Standard requests
  *         for RTLSDR class.
  * @param  phost: Host handle
  * @retval USBH Status
  */


/**
  * @brief  RTLSDR_probe_tuners
  *         This is a sub-FSM to check what tuner we have.
  * @param  phost: Host handle
  * @retval USBH Status
  */




/**
  * @brief  USBH_RTLSDR_Process
  *         The function is for managing state machine for RTLSDR data transfers
  * @param  phost: Host handle
  * @retval USBH Status
  */
