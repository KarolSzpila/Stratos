/*
 * fm_radio.c
 *
 *  Created on: 01.09.2017
 *      Author: Karol
 */

#include "fm_radio.h"
#include "stm32f4xx_hal.h"
#include "string.h"
#include <stdint.h>
#include <math.h>

#define SIZE 1024
static struct FMRadio self;

unsigned char usbbuf[SIZE];
uint16_t magnitude[SIZE];
uint16_t maglut[129*129*2];

static int r = -1;

#define MODES_PREAMBLE_US 8       /* microseconds */
#define MODES_LONG_MSG_BITS 112
#define MODES_SHORT_MSG_BITS 56
#define MODES_FULL_LEN (MODES_PREAMBLE_US+MODES_LONG_MSG_BITS)
#define MODES_LONG_MSG_BYTES (112/8)
#define MODES_SHORT_MSG_BYTES (56/8)

uint32_t modesChecksum(unsigned char *msg, int bits) {
    uint32_t crc = 0;
    int offset = (bits == 112) ? 0 : (112-56);
    int j;

    for(j = 0; j < bits; j++) {
        int byte = j/8;
        int bit = j%8;
        int bitmask = 1 << (7-bit);

        /* If bit is set, xor with corresponding table entry. */
        if (msg[byte] & bitmask)
            crc ^= modes_checksum_table[j+offset];
    }
    return crc; /* 24 bit checksum. */
}

void decodeModesMessage(struct modesMessage *mm, unsigned char *msg) {
    uint32_t crc2;   /* Computed CRC, used to verify the message CRC. */
    char *ais_charset = "?ABCDEFGHIJKLMNOPQRSTUVWXYZ????? ???????????????0123456789??????";

    /* Work on our local copy */
    memcpy(mm->msg,msg,MODES_LONG_MSG_BYTES);
    msg = mm->msg;

    /* Get the message type ASAP as other operations depend on this */
    mm->msgtype = msg[0]>>3;    /* Downlink Format */
    mm->msgbits = modesMessageLenByType(mm->msgtype);

    /* CRC is always the last three bytes. */
    mm->crc = ((uint32_t)msg[(mm->msgbits/8)-3] << 16) |
              ((uint32_t)msg[(mm->msgbits/8)-2] << 8) |
               (uint32_t)msg[(mm->msgbits/8)-1];
    crc2 = modesChecksum(msg,mm->msgbits);

    /* Check CRC and fix single bit errors using the CRC when
     * possible (DF 11 and 17). */
    mm->errorbit = -1;  /* No error */
    mm->crcok = (mm->crc == crc2);
}


void computeMagnitudeVector(void) {
    uint32_t j;

    /* Compute the magnitudo vector. It's just SQRT(I^2 + Q^2), but
     * we rescale to the 0-255 range to exploit the full resolution. */
    for (j = 0; j < SIZE; j += 2) {
        int i = usbbuf[j]-127;
        int q = usbbuf[j+1]-127;

        if (i < 0) i = -i;
        if (q < 0) q = -q;
        magnitude[j/2] = maglut[i*129+q];
    }

}

int modesMessageLenByType(int type) {
    if (type == 16 || type == 17 ||
        type == 19 || type == 20 ||
        type == 21)
        return MODES_LONG_MSG_BITS;
    else
        return MODES_SHORT_MSG_BITS;
}

void detectModeS(uint16_t *m, uint32_t mlen) {
    unsigned char bits[MODES_LONG_MSG_BITS];
    unsigned char msg[MODES_LONG_MSG_BITS/2];
    uint16_t aux[MODES_LONG_MSG_BITS*2];
    uint32_t j;
    int use_correction = 0;

    for (j = 0; j < mlen - MODES_FULL_LEN*2; j++) {
        int low, high, delta, i, errors;
        int good_message = 0;

        //if (use_correction) goto good_preamble; /* We already checked it. */

        /* First check of relations between the first 10 samples
         * representing a valid preamble. We don't even investigate further
         * if this simple test is not passed. */
        if (!(magnitude[j] > magnitude[j+1] &&
            magnitude[j+1] < magnitude[j+2] &&
            magnitude[j+2] > magnitude[j+3] &&
            magnitude[j+3] < magnitude[j] &&
            magnitude[j+4] < magnitude[j] &&
            magnitude[j+5] < magnitude[j] &&
            magnitude[j+6] < magnitude[j] &&
            magnitude[j+7] > magnitude[j+8] &&
            magnitude[j+8] < magnitude[j+9] &&
            magnitude[j+9] > magnitude[j+6]))
        {
        	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_13,GPIO_PIN_SET);
            break;
        }


        high = (magnitude[j]+magnitude[j+2]+magnitude[j+7]+magnitude[j+9])/6;
        if (magnitude[j+4] >= high ||
        		magnitude[j+5] >= high)
        {
        	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_13,GPIO_PIN_SET);
            break;
        }

        if (magnitude[j+11] >= high ||
        		magnitude[j+12] >= high ||
				magnitude[j+13] >= high ||
				magnitude[j+14] >= high)
        {
        	HAL_GPIO_WritePin(GPIOG,GPIO_PIN_13,GPIO_PIN_SET);
            break;
        }

        errors = 0;
              for (i = 0; i < MODES_LONG_MSG_BITS*2; i += 2) {
                  low = m[j+i+MODES_PREAMBLE_US*2];
                  high = m[j+i+MODES_PREAMBLE_US*2+1];
                  delta = low-high;
                  if (delta < 0) delta = -delta;

                  if (i > 0 && delta < 256) {
                      bits[i/2] = bits[i/2-1];
                  } else if (low == high) {
                      /* Checking if two adiacent samples have the same magnitude
                       * is an effective way to detect if it's just random noise
                       * that was detected as a valid preamble. */
                      bits[i/2] = 2; /* error */
                      if (i < MODES_SHORT_MSG_BITS*2) errors++;
                  } else if (low > high) {
                      bits[i/2] = 1;
                  } else {
                      /* (low < high) for exclusion  */
                      bits[i/2] = 0;
                  }
              }

              /* Pack bits into bytes */
              for (i = 0; i < MODES_LONG_MSG_BITS; i += 8) {
                  msg[i/8] =
                      bits[i]<<7 |
                      bits[i+1]<<6 |
                      bits[i+2]<<5 |
                      bits[i+3]<<4 |
                      bits[i+4]<<3 |
                      bits[i+5]<<2 |
                      bits[i+6]<<1 |
                      bits[i+7];
              }

              int msgtype = msg[0]>>3;
              int msglen = modesMessageLenByType(msgtype)/8;

              delta = 0;
              for (i = 0; i < msglen*8*2; i += 2) {
                  delta += abs(m[j+i+MODES_PREAMBLE_US*2]-
                               m[j+i+MODES_PREAMBLE_US*2+1]);
              }
              delta /= msglen*4;

              /* Filter for an average delta of three is small enough to let almost
               * every kind of message to pass, but high enough to filter some
               * random noise. */
              if (delta < 10*255) {
                  break;
              }

              if (errors != 0 )
              {
            	  break;
              }

              struct modesMessage mm;

                        /* Decode the received message and update statistics */
              decodeModesMessage(&mm,msg);

        HAL_GPIO_WritePin(GPIOG,GPIO_PIN_14,GPIO_PIN_SET);
    }
}

int fmradio_init() {

    dev = &static_dev;

    self.tuner_ppm_error = 0;
    self.tuner_frequency = 1090000000;
    self.adc_samp_rate = 2000000;
    self.is_raw_buf_complete = 0;

    memset(usbbuf,0,SIZE);
    memset(magnitude,0,SIZE);


       for (uint8_t i = 0; i <= 128; i++) {
           for (uint8_t q = 0; q <= 128; q++) {
               maglut[i*129+q] = round(sqrt(i*i+q*q)*360);
           }
       }


    int8_t dongle_open = rtlsdr_open(&dev, 0);

    if (dongle_open < 0) {
        //DEBUG_PRINT("Failed to open rtlsdr device (%i).\n", dongle_open);
        return dongle_open;
    } else {
        //DEBUG_PRINT("Opened rtlsdr\n");
    }

    // Set the sample rate
    r = verbose_set_sample_rate(dev, self.adc_samp_rate);

    // Set the frequency
    r = verbose_set_frequency(dev, self.tuner_frequency);

    // set auto gain
    r = verbose_auto_gain(dev);

    // set ppm error
    r = verbose_ppm_set(dev, self.tuner_ppm_error);

    // Reset endpoint before we start reading from it (mandatory)
    r = verbose_reset_buffer(dev);

    //DEBUG_PRINT("Starting user app\n");
    usbbuf[512] = 'a';
    // begin capture radio data
    self.is_usb_app_started = 1;
    rtlsdr_read_sync(dev, usbbuf, 8, 0);
    return 0;

}

void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
{
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif

  UNUSED(hhcd);
  UNUSED(chnum);

  if (!self.is_usb_app_started) { return; }

  if (urb_state == URB_DONE)
  {

	  computeMagnitudeVector();
	  detectModeS(magnitude,512);
	  rtlsdr_read_sync(dev, usbbuf, 8, 0);
  }
  else if(urb_state == URB_ERROR)
  {
	  //HAL_GPIO_TogglePin(GPIOG,GPIO_PIN_13);
  }
}
/*
void fmradio_process() {

    // run init
    if (!self.is_usb_app_started) fmradio_init();

    // wait for raw buffer to fill completely
    if (!self.is_raw_buf_complete) return;

    // reset buffer completion flag
    self.is_raw_buf_complete = 0;

    // trace event
    trace_itm_print(3,0);

    // demodulate and downsample the completed raw buffer
    uint32_t demod_index = 0;
    volatile uint8_t* raw_buf_complete = (raw_buf_filling == raw_bufA) ? raw_bufB : raw_bufA;

    for (uint32_t sample_index = 0;
            (sample_index + (2 * DOWNSAMPLE) + 3) < RAW_BUFFER_BYTES;
            sample_index += 2 * DOWNSAMPLE) {

        // todo reconsider -127 offset as samples are actually only 7-bit reso
        int16_t s1[2], s2[2];
        s1[0] = (int16_t)raw_buf_complete[sample_index + 0] - 127; // I
        s1[1] = (int16_t)raw_buf_complete[sample_index + 1] - 127; // Q
        s2[0] = (int16_t)raw_buf_complete[sample_index + 2] - 127; // I
        s2[1] = (int16_t)raw_buf_complete[sample_index + 3] - 127; // Q

        // find the phase shift in these two samples (this is the essence of the FM demod)
        int16_t pcm = fmradio_polar_disc(s2[0], s2[1], s1[0], s1[1]);

        pcm = pcm * 8.0f / PI; // scale from radians

        // TODO: dc block filter and low pass filter

        // note: audio codec currently expects stereo sample buffer
        curr_demod_buff[demod_index++] = pcm; // right channel
        curr_demod_buff[demod_index++] = pcm; // left channel

    }

    // play demodulated buffer
    audio_set_next_segment((int16_t*)curr_demod_buff, 2*demod_index);

    // swap demod buffers
    curr_demod_buff = (curr_demod_buff == demod_bufferA) ? demod_bufferB : demod_bufferA;

}*/
